package provider

import (
	"errors"
	"fmt"
	"slices"
	"strconv"

	"github.com/guguducken/ddns-go/pkg/config"
	"github.com/rs/zerolog/log"
	tcam "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/cam/v20190116"
	tcommon "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/common"
	"github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/common/profile"
	dnspod "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/dnspod/v20210323"
)

const (
	dnsPodAPIEndpoint     = `dnspod.tencentcloudapi.com`
	tencentCAMAPIEndpoint = "cam.tencentcloudapi.com"
)

type DNSPod struct {
	accessKey string
	secretKey string
	domains   config.DNSRecords

	credential *tcommon.Credential
}

// NewDNSPodProvider will return nil pointer if accessKey is empty or secretKey is empty
func NewDNSPodProvider(accessKey string, secretKey string, domains config.DNSRecords) *DNSPod {
	if accessKey == "" || secretKey == "" {
		return nil
	}
	d := &DNSPod{
		accessKey:  accessKey,
		secretKey:  secretKey,
		domains:    domains,
		credential: tcommon.NewCredential(accessKey, secretKey),
	}
	d.FillUpDefaultValue()
	return d
}

func (d *DNSPod) Do(ip string) error {
	errs := make([]error, 0, 10)
	for i := 0; i < len(d.domains); i++ {
		domain := d.domains[i]
		if domain.Value != "" && domain.Value == ip {
			log.Info().Msg(fmt.Sprintf("the value of domain %s.%s is equal current ip %s", domain.SubDomain, domain.Domain, ip))
			continue
		}

		// set record value to recent ip
		domain.Value = ip
		domain.Type = CheckIPDNSType(ip)

		remoteRecord, err := d.GetDNSRecord(domain.Domain, domain.SubDomain)

		if err != nil {
			if errors.Is(err, ErrNoDNSRecord) {
				var id uint64
				id, err = d.CreateDNSRecord(domain)
				if err != nil {
					errs = append(errs, err)
				}
				domain.ID = id
			} else {
				errs = append(errs, err)
			}
			continue
		}

		domain.ID = remoteRecord.ID
		if err = d.UpdateDNSRecord(domain); err != nil {
			errs = append(errs, err)
			continue
		}
		d.domains[i] = domain
	}

	if len(errs) != 0 {
		return errors.Join(errs...)
	}
	return nil
}

func (d *DNSPod) FillUpDefaultValue() {
	if len(d.domains) == 0 {
		return
	}
	for i := 0; i < len(d.domains); i++ {
		if d.domains[i].Type == "" {
			d.domains[i].Type = DNSPodProvider
		}
		if d.domains[i].Line == "" {
			d.domains[i].Line = "默认"
		}
		if d.domains[i].Status == "" {
			d.domains[i].Status = "ENABLE"
		}
		if d.domains[i].Remark == "" {
			d.domains[i].Remark = "Generated by ddns-go"
		}
		if d.domains[i].Weight == 0 {
			d.domains[i].Weight = 100
		}
		if d.domains[i].TTL == 0 {
			d.domains[i].TTL = 600
		}
	}
}

func (d *DNSPod) NewDNSPodClient() (*dnspod.Client, error) {
	cpf := profile.NewClientProfile()
	cpf.HttpProfile.Endpoint = dnsPodAPIEndpoint
	cpf.NetworkFailureMaxRetries = 10
	cpf.UnsafeRetryOnConnectionFailure = true
	return dnspod.NewClient(d.credential, "", cpf)
}

func (d *DNSPod) NewTencentCAMClient() (*tcam.Client, error) {
	cpf := profile.NewClientProfile()
	cpf.HttpProfile.Endpoint = tencentCAMAPIEndpoint
	cpf.NetworkFailureMaxRetries = 10
	cpf.UnsafeRetryOnConnectionFailure = true
	return tcam.NewClient(d.credential, "", cpf)
}

func (d *DNSPod) GetType() string {
	return DNSPodProvider
}

func (d *DNSPod) CheckPermission() error {
	userUID, err := d.getUserUid()
	if err != nil {
		return err
	}
	allowedPermissions := []string{"AdministratorAccess", "QCloudResourceFullAccess", "QcloudDNSPodFullAccess", "CustomerDNSPodFullAccess"}

	request := tcam.NewListPoliciesGrantingServiceAccessRequest()
	request.TargetUin = tcommon.Uint64Ptr(userUID)

	client, err := d.NewTencentCAMClient()

	response, err := client.ListPoliciesGrantingServiceAccess(request)
	if err != nil {
		return err
	}

	checkDetailPermission := func(node *tcam.ListGrantServiceAccessNode) bool {
		if *node.Service.ServiceType != "dnspod" {
			return false
		}
		for _, policy := range node.Policy {
			if slices.Contains(allowedPermissions, *policy.PolicyName) {
				return true
			}
		}
		return false
	}

	for _, node := range response.Response.List {
		if checkDetailPermission(node) {
			return nil
		}
	}
	return ErrPermissionInvalid
}

func (d *DNSPod) GetDNSRecord(domain string, subDomain string) (config.DNSRecord, error) {
	log.Info().Msg(fmt.Sprintf("start get dns record for %s.%s", subDomain, domain))
	var record config.DNSRecord

	// init new request
	request := dnspod.NewDescribeRecordFilterListRequest()

	request.Domain = tcommon.StringPtr(domain)
	request.SubDomain = tcommon.StringPtr(subDomain)
	request.IsExactSubDomain = tcommon.BoolPtr(true)
	request.Limit = tcommon.Uint64Ptr(100)

	// init client
	client, err := d.NewDNSPodClient()
	if err != nil {
		return record, err
	}

	response, err := client.DescribeRecordFilterList(request)
	if err != nil {
		return record, err
	}

	if *response.Response.RecordCountInfo.ListCount == 0 || len(response.Response.RecordList) == 0 {
		return record, errors.Join(ErrNoDNSRecord,
			errors.New(fmt.Sprintf("provider: %s, domain: %s, subDomain: %s", DNSPodProvider, domain, subDomain)))
	}

	// we can get only one record
	// parse to DNSRecord
	record = d.ParseToDNSRecord(domain, response.Response.RecordList[0])
	return record, nil
}

func (d *DNSPod) ListDNSRecords(domain string) (config.DNSRecords, error) {
	records := make(config.DNSRecords, 0, 30)

	var offset, limit uint64 = 0, 200
	for {
		recordsTemp, err := d.listDNSRecordByPage(domain, offset, limit)
		if err != nil {
			return nil, err
		}
		records = append(records, recordsTemp...)
		offset += limit
		if len(recordsTemp) < int(limit) {
			break
		}
	}

	return records, nil
}

func (d *DNSPod) listDNSRecordByPage(domain string, offset uint64, limit uint64) (config.DNSRecords, error) {
	records := make(config.DNSRecords, 0, 30)

	request := dnspod.NewDescribeRecordListRequest()
	request.Domain = tcommon.StringPtr(domain)
	request.Offset = tcommon.Uint64Ptr(offset)
	request.Limit = tcommon.Uint64Ptr(limit)

	client, err := d.NewDNSPodClient()
	if err != nil {
		return nil, err
	}

	response, err := client.DescribeRecordList(request)
	if err != nil {
		return nil, err
	}

	for _, item := range response.Response.RecordList {
		records = append(records, d.ParseToDNSRecord(domain, item))
	}

	return records, nil
}

func (d *DNSPod) CreateDNSRecord(record config.DNSRecord) (id uint64, err error) {
	if err = record.Validate(); err != nil {
		return 0, err
	}

	request := dnspod.NewCreateRecordRequest()
	request.Domain = tcommon.StringPtr(record.Domain)
	request.RecordType = tcommon.StringPtr(CheckIPDNSType(record.Value))
	request.RecordLine = tcommon.StringPtr(record.Line)
	request.Value = tcommon.StringPtr(record.Value)
	request.SubDomain = tcommon.StringPtr(record.SubDomain)
	request.TTL = tcommon.Uint64Ptr(record.TTL)
	request.Weight = tcommon.Uint64Ptr(record.Weight)
	request.Status = tcommon.StringPtr(record.Status)
	request.Remark = tcommon.StringPtr(record.Remark)

	client, err := d.NewDNSPodClient()
	if err != nil {
		return 0, err
	}
	response, err := client.CreateRecord(request)
	if err != nil {
		return 0, err
	}
	return *response.Response.RecordId, err
}

func (d *DNSPod) UpdateDNSRecord(record config.DNSRecord) error {
	log.Info().Msg(fmt.Sprintf("start update dns record for %s.%s, value is %s", record.SubDomain, record.Domain, record.Value))

	request := dnspod.NewModifyRecordRequest()
	request.RecordId = tcommon.Uint64Ptr(record.ID)

	request.Domain = tcommon.StringPtr(record.Domain)
	request.SubDomain = tcommon.StringPtr(record.SubDomain)
	request.RecordType = tcommon.StringPtr(record.Type)
	request.RecordLine = tcommon.StringPtr(record.Line)
	request.Value = tcommon.StringPtr(record.Value)
	request.TTL = tcommon.Uint64Ptr(record.TTL)
	request.Weight = tcommon.Uint64Ptr(record.Weight)

	// init client
	client, err := d.NewDNSPodClient()
	if err != nil {
		return err
	}
	_, err = client.ModifyRecord(request)
	return err
}

func (d *DNSPod) DeleteDNSRecord(record config.DNSRecord) error {
	if err := record.Validate(); err != nil {
		return err
	}
	return nil
}

func (d *DNSPod) ParseToDNSRecord(domain string, dnsPodRecord *dnspod.RecordListItem) config.DNSRecord {
	log.Debug().Msg(fmt.Sprintf("parse dnspod record %s.%s to config.Record", *dnsPodRecord.Name, domain))
	record := config.DNSRecord{
		ID:         *dnsPodRecord.RecordId,
		Domain:     domain,
		SubDomain:  *dnsPodRecord.Name,
		Value:      *dnsPodRecord.Value,
		Status:     *dnsPodRecord.Status,
		Type:       *dnsPodRecord.Type,
		MX:         *dnsPodRecord.MX,
		Line:       *dnsPodRecord.Line,
		TTL:        *dnsPodRecord.TTL,
		UpdateTime: *dnsPodRecord.UpdatedOn,
	}
	if dnsPodRecord.Remark != nil {
		record.Remark = *dnsPodRecord.Remark
	}
	if dnsPodRecord.Weight != nil {
		record.Weight = *dnsPodRecord.Weight
	}
	return record
}

func (d *DNSPod) getUserUid() (uint64, error) {
	// get user uid
	request := tcam.NewGetUserAppIdRequest()

	client, err := d.NewTencentCAMClient()
	if err != nil {
		return 0, err
	}

	response, err := client.GetUserAppId(request)
	if err != nil {
		return 0, err
	}
	return strconv.ParseUint(*response.Response.Uin, 10, 64)
}
